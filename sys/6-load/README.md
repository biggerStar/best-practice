# 装载
## 装载的方式
- 静态装载：将程序所需要的指令和数据都装入内存，然后执行
- 动态装载：静态装载的问题在于需要大量的内存，当内存小于需要时，则不能完成。动态装载是将最常用的部分驻留在内存中，而将一些不太常用的数据存放在磁盘里

## 动态装载
- 覆盖装载
覆盖装载就是手动将一个调用链上的所有模块都装入内存，而非调用用链上的模块不用.这样不用同一时间将所有模块装载，达到节省空间的效果

- 页映射
将内存和磁盘中的程序和数据分为页传入，目前硬件层面的页的规格有4k,8k,2M,4M等。例如IntelA32处理器使用4k的页，那么512M的内存拥有512*1024*1024/4096 = 131 072	个页。
> * 有个内存为16k的机器，运行32k程序的时候，流程如下：首先，将32k程序分为8个页（每页大小为4k），然后将最先使用的页读入内存。当内存不够用时，需要换出，常用的算法有先进先出FIFO，最少使用LUR，LRU等算法。
这就是ELF和widows的PE文件的装载方式。

## 可执行文件的装载
### 进程的建立
- 创建一个独立的虚拟空间
虚拟空间并不是空间，而是一个虚拟地址与物理地址的映射（数据结构）
- 读取可执行文件头，建立虚拟空间和可执行文件的映射
上一步创建的是虚拟空间到物理空间的映射，这一步是建立虚拟空间与可执行文件的映射(VMA)。当操作系统需要载入某段虚拟空间内容时，他会去VMA中查找相应的elf文件偏移，然后读取内容。
- 将cpu的指令寄存器设置为可执行文件的入口，启动运行

### 页错误
当程序读取某个地址的时候，发现改虚地址没有对应的物理地址，于是发出页错误，并将控制权交给操作系统。操作系统找到该虚拟地址VMA，找到elf文件的偏移，然后在物理内存中分配一个物理页面，建立映射关系。最后将控制权交给进程
 
## 进程虚拟空间分布
### elf
elf文件包含.text .code .bss等非常多的段，如果每个段都与虚拟空间做映射，会产生很多空间碎片。于是将权限相同的段合并起来, 映射为一个VMA。
```
readelf -l SectionMapping.elf ##查看elf文件如何被操作系统映射到进程的虚拟空间
```
### 堆和栈
进程在执行中需要用到的堆和栈等空间，他们在进程的虚拟空间只能够的表现也是以VMA形式存在，通常来说，一个进程中的堆和栈分别对应一个vma
```
./SectionMapping.elf & // 先把进程启动
cat /proc/{pid}/maps //查看进程虚拟空间分布
```
其中包括[stack] [heap]两个vma，以及其他几个映射到文件的vma，还有一个与内核通信的vma，[vdso].具体来说：
- 代码VMA，只读，可执行；有映像文件
- 数据VMA，可读写，可执行，有映像文件
- 堆VMA，可读写，可执行；无映像文件，匿名，可向上扩展（地址空间）
- 栈VMA，可读写，不可执行；无映像文件，匿名，可向下扩展
### 进程初始化
程序运行时的环境变量，在启动进程之前，需要被保存到进程的虚拟空间的栈（VMA中的Stack VMA）中。在进程启动之后，会把堆栈里的初始化信息中的参数传递给main函数，例如argc和argv两个参数.

## linux 内核装载ELF过程
- 首先，在用户态，bash进程调用fork（）系统调用创建一个新进程
- 然后，新的进程调用execve()系统调用，执行指定的elf文件。
```
int execve(const char *filename, char *const argv[], char *const envp[]);
```
> * 通过文件头128个字节判断文件类型，不同类型文件启动不同的装载过程。
> * elf的话，使用load_elf_binary()处理。处理过程如下：
> * 1、检查elf文件的有效性，包括魔数，程序头表段的数量
> * 2、寻找动态链接的“.interp”段，设置动态链接器的路径
> * 3、根据elf可执行文件的程序头表的描述，对elf文件进行映射，如代码、数据、只读数据等
> * 4、初始化elf进程环境，比如进程启动时的EDX寄存器地址应该是DT_FINI地址
> * 5、将系统调用的返回值设置为ELF可执行文件的入口点。


